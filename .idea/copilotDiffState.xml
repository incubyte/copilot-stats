<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/backend/src/main.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/backend/src/main.ts" />
              <option name="originalContent" value="import { NestFactory } from '@nestjs/core';&#10;import { AppModule } from './app.module';&#10;&#10;async function bootstrap() {&#10;  const app = await NestFactory.create(AppModule);&#10;  app.enableCors({&#10;    origin: 'http://localhost:8008',&#10;  });&#10;  await app.listen(process.env.PORT || '3006');&#10;}&#10;bootstrap();&#10;" />
              <option name="updatedContent" value="import { NestFactory } from '@nestjs/core';&#10;import { AppModule } from './app.module';&#10;&#10;async function bootstrap() {&#10;  const app = await NestFactory.create(AppModule);&#10;  app.enableCors({&#10;    origin: 'http://localhost:8008',&#10;  });&#10;  await app.listen(process.env.PORT || '3006');&#10;}&#10;bootstrap();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/backend/test/github/github.controller.integration.spec.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/backend/test/github/github.controller.integration.spec.ts" />
              <option name="originalContent" value="import { Test, TestingModule } from '@nestjs/testing';&#10;import { INestApplication } from '@nestjs/common';&#10;import { ConfigModule, ConfigService } from '@nestjs/config';&#10;import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';&#10;import request from 'supertest';&#10;import { GitHubController } from '../../src/github/github.controller';&#10;import { GitHubService } from '../../src/github/github.service';&#10;import {&#10;  mockCopilotSeats,&#10;  mockCopilotUsageMetrics,&#10;  mockCurrentUser,&#10;  mockPullRequestReviews,&#10;  mockPullRequests,&#10;} from '../setup';&#10;&#10;describe('GitHubController (Integration)', () =&gt; {&#10;  let app: INestApplication;&#10;  let githubController: GitHubController;&#10;&#10;  beforeEach(async () =&gt; {&#10;    const moduleFixture: TestingModule = await Test.createTestingModule({&#10;      imports: [&#10;        ConfigModule.forRoot({&#10;          isGlobal: true,&#10;          envFilePath: '.env.test',&#10;        }),&#10;      ],&#10;      controllers: [GitHubController],&#10;      providers: [&#10;        GitHubService,&#10;        {&#10;          provide: ConfigService,&#10;          useValue: {&#10;            get: vi.fn((key: string) =&gt; {&#10;              const config = {&#10;                GITHUB_TOKEN: 'test-token',&#10;                GITHUB_ORG: 'test-org',&#10;              };&#10;              return config[key];&#10;            }),&#10;          },&#10;        },&#10;      ],&#10;    }).compile();&#10;&#10;    app = moduleFixture.createNestApplication();&#10;    githubController = moduleFixture.get&lt;GitHubController&gt;(GitHubController);&#10;    await app.init();&#10;  });&#10;&#10;  afterEach(async () =&gt; {&#10;    await app.close();&#10;  });&#10;&#10;  describe('GET /github/user', () =&gt; {&#10;    it('should return current authenticated user information', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/user')&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockCurrentUser);&#10;      expect(response.body.login).toBe('advait-incubyte');&#10;      expect(response.body.company).toBe('@incubyte');&#10;    });&#10;&#10;    it('should handle authentication errors gracefully', async () =&gt; {&#10;      // This test would require modifying the MSW handler to return 401&#10;      // We'll implement this in the service unit tests&#10;    });&#10;  });&#10;&#10;  describe('GET /github/copilot/usage', () =&gt; {&#10;    it('should return Copilot usage metrics for the organization', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/usage')&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockCopilotUsageMetrics);&#10;      expect(Array.isArray(response.body)).toBe(true);&#10;      expect(response.body[0]).toHaveProperty('day');&#10;      expect(response.body[0]).toHaveProperty('total_suggestions_count');&#10;      expect(response.body[0]).toHaveProperty('total_acceptances_count');&#10;      expect(response.body[0]).toHaveProperty('breakdown');&#10;    });&#10;&#10;    it('should accept since and until query parameters', async () =&gt; {&#10;      const since = '2025-01-01';&#10;      const until = '2025-01-31';&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/copilot/usage?since=${since}&amp;until=${until}`)&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockCopilotUsageMetrics);&#10;      // In a real implementation, we'd verify the query params were passed to the API&#10;    });&#10;&#10;    it('should return meaningful data structure for frontend consumption', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/usage')&#10;        .expect(200);&#10;&#10;      const usageData = response.body[0];&#10;&#10;      // Verify the data contains everything the frontend needs&#10;      expect(usageData.total_active_users).toBe(3); // Your 3 teammates&#10;      expect(usageData.breakdown).toHaveLength(2); // TypeScript and JavaScript&#10;      expect(usageData.breakdown[0]).toHaveProperty('language');&#10;      expect(usageData.breakdown[0]).toHaveProperty('editor');&#10;      expect(usageData.breakdown[0]).toHaveProperty('acceptances_count');&#10;    });&#10;  });&#10;&#10;  describe('GET /github/copilot/seats', () =&gt; {&#10;    it('should return Copilot seat information for team members', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/seats')&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockCopilotSeats);&#10;      expect(response.body.total_seats).toBe(5);&#10;      expect(response.body.seats).toHaveLength(3); // Your 3 teammates&#10;      expect(response.body.seats[0].assignee.login).toBe('teammate1');&#10;    });&#10;&#10;    it('should provide seat data needed for filtering usage metrics', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/seats')&#10;        .expect(200);&#10;&#10;      const seats = response.body.seats;&#10;&#10;      // Verify we can identify your specific teammates&#10;      const teammateLogins = seats.map((seat) =&gt; seat.assignee.login);&#10;      expect(teammateLogins).toContain('teammate1');&#10;      expect(teammateLogins).toContain('teammate2');&#10;      expect(teammateLogins).toContain('teammate3');&#10;&#10;      // Verify we have activity information&#10;      seats.forEach((seat) =&gt; {&#10;        expect(seat).toHaveProperty('last_activity_at');&#10;        expect(seat).toHaveProperty('last_activity_editor');&#10;      });&#10;    });&#10;  });&#10;&#10;  describe('GET /github/repos/:repo/pulls', () =&gt; {&#10;    it('should return pull requests for a specific repository', async () =&gt; {&#10;      const repo = 'test-repo';&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls`)&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockPullRequests);&#10;      expect(Array.isArray(response.body)).toBe(true);&#10;      expect(response.body[0]).toHaveProperty('number');&#10;      expect(response.body[0]).toHaveProperty('title');&#10;      expect(response.body[0]).toHaveProperty('user');&#10;    });&#10;&#10;    it('should accept since query parameter for date filtering', async () =&gt; {&#10;      const repo = 'test-repo';&#10;      const since = '2025-01-01';&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls?since=${since}`)&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockPullRequests);&#10;    });&#10;  });&#10;&#10;  describe('GET /github/repos/:repo/pulls/:pullNumber/reviews', () =&gt; {&#10;    it('should return reviews for a specific pull request', async () =&gt; {&#10;      const repo = 'test-repo';&#10;      const pullNumber = 123;&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls/${pullNumber}/reviews`)&#10;        .expect(200);&#10;&#10;      expect(response.body).toEqual(mockPullRequestReviews);&#10;      expect(Array.isArray(response.body)).toBe(true);&#10;    });&#10;&#10;    it('should include both human and bot reviews for Copilot detection', async () =&gt; {&#10;      const repo = 'test-repo';&#10;      const pullNumber = 123;&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls/${pullNumber}/reviews`)&#10;        .expect(200);&#10;&#10;      const reviews = response.body;&#10;&#10;      // Should have both bot and human reviews&#10;      const botReview = reviews.find((review) =&gt; review.user.type === 'Bot');&#10;      const humanReview = reviews.find((review) =&gt; review.user.type === 'User');&#10;&#10;      expect(botReview).toBeDefined();&#10;      expect(humanReview).toBeDefined();&#10;      expect(botReview.user.login).toBe('github-actions[bot]');&#10;    });&#10;  });&#10;&#10;  describe('GET /github/copilot/summary', () =&gt; {&#10;    it('should return a combined summary of Copilot metrics for last 28 days', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/summary')&#10;        .expect(200);&#10;&#10;      expect(response.body).toHaveProperty('period');&#10;      expect(response.body).toHaveProperty('usage_metrics');&#10;      expect(response.body).toHaveProperty('seat_info');&#10;      expect(response.body).toHaveProperty('summary');&#10;&#10;      // Verify period calculation&#10;      expect(response.body.period.days).toBe(28);&#10;      expect(response.body.period.since).toBeDefined();&#10;      expect(response.body.period.until).toBeDefined();&#10;&#10;      // Verify summary statistics&#10;      expect(response.body.summary.total_seats).toBe(5);&#10;      expect(response.body.summary.total_active_users).toBe(1); // Length of mock usage metrics array&#10;    });&#10;&#10;    it('should provide data structure suitable for dashboard display', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/summary')&#10;        .expect(200);&#10;&#10;      const summary = response.body;&#10;&#10;      // Frontend should be able to easily extract key metrics&#10;      expect(typeof summary.summary.total_seats).toBe('number');&#10;      expect(typeof summary.summary.total_active_users).toBe('number');&#10;      expect(Array.isArray(summary.usage_metrics)).toBe(true);&#10;      expect(Array.isArray(summary.seat_info.seats)).toBe(true);&#10;    });&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { Test, TestingModule } from '@nestjs/testing';&#10;import { INestApplication } from '@nestjs/common';&#10;import { ConfigModule, ConfigService } from '@nestjs/config';&#10;import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';&#10;import request from 'supertest';&#10;import { GitHubController } from '../../src/github/github.controller';&#10;import { GitHubService } from '../../src/github/github.service';&#10;import {&#10;  mockCopilotSeats,&#10;  mockCopilotUsageMetrics,&#10;  mockCurrentUser,&#10;  mockPullRequestReviews,&#10;  mockPullRequests,&#10;  type GitHubUser,&#10;  type CopilotUsageMetrics,&#10;  type CopilotSeats,&#10;  type PullRequest,&#10;  type PullRequestReview,&#10;  type CopilotSummary,&#10;} from '../setup';&#10;&#10;describe('GitHubController (Integration)', () =&gt; {&#10;  let app: INestApplication;&#10;&#10;  beforeEach(async () =&gt; {&#10;    const moduleFixture: TestingModule = await Test.createTestingModule({&#10;      imports: [&#10;        ConfigModule.forRoot({&#10;          isGlobal: true,&#10;          envFilePath: '.env.test',&#10;        }),&#10;      ],&#10;      controllers: [GitHubController],&#10;      providers: [&#10;        GitHubService,&#10;        {&#10;          provide: ConfigService,&#10;          useValue: {&#10;            get: vi.fn((key: string): string =&gt; {&#10;              const config: Record&lt;string, string&gt; = {&#10;                GITHUB_TOKEN: 'test-token',&#10;                GITHUB_ORG: 'test-org',&#10;              };&#10;              return config[key] ?? '';&#10;            }),&#10;          },&#10;        },&#10;      ],&#10;    }).compile();&#10;&#10;    app = moduleFixture.createNestApplication();&#10;    await app.init();&#10;  });&#10;&#10;  afterEach(async () =&gt; {&#10;    await app.close();&#10;  });&#10;&#10;  describe('GET /github/user', () =&gt; {&#10;    it('should return current authenticated user information', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/user')&#10;        .expect(200);&#10;&#10;      const user = response.body as GitHubUser;&#10;      expect(user).toEqual(mockCurrentUser);&#10;      expect(user.login).toBe('advait-incubyte');&#10;      expect(user.company).toBe('@incubyte');&#10;    });&#10;&#10;    it('should handle authentication errors gracefully', async () =&gt; {&#10;      // This test would require modifying the MSW handler to return 401&#10;      // We'll implement this in the service unit tests&#10;    });&#10;  });&#10;&#10;  describe('GET /github/copilot/usage', () =&gt; {&#10;    it('should return Copilot usage metrics for the organization', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/usage')&#10;        .expect(200);&#10;&#10;      const usageMetrics = response.body as CopilotUsageMetrics[];&#10;      expect(usageMetrics).toEqual(mockCopilotUsageMetrics);&#10;      expect(Array.isArray(usageMetrics)).toBe(true);&#10;      expect(usageMetrics[0]).toHaveProperty('day');&#10;      expect(usageMetrics[0]).toHaveProperty('total_suggestions_count');&#10;      expect(usageMetrics[0]).toHaveProperty('total_acceptances_count');&#10;      expect(usageMetrics[0]).toHaveProperty('breakdown');&#10;    });&#10;&#10;    it('should accept since and until query parameters', async () =&gt; {&#10;      const since = '2025-01-01';&#10;      const until = '2025-01-31';&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/copilot/usage?since=${since}&amp;until=${until}`)&#10;        .expect(200);&#10;&#10;      const usageMetrics = response.body as CopilotUsageMetrics[];&#10;      expect(usageMetrics).toEqual(mockCopilotUsageMetrics);&#10;      // In a real implementation, we'd verify the query params were passed to the API&#10;    });&#10;&#10;    it('should return meaningful data structure for frontend consumption', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/usage')&#10;        .expect(200);&#10;&#10;      const usageMetrics = response.body as CopilotUsageMetrics[];&#10;      const usageData = usageMetrics[0];&#10;&#10;      // Verify the data contains everything the frontend needs&#10;      expect(usageData.total_active_users).toBe(3); // Your 3 teammates&#10;      expect(usageData.breakdown).toHaveLength(2); // TypeScript and JavaScript&#10;      expect(usageData.breakdown[0]).toHaveProperty('language');&#10;      expect(usageData.breakdown[0]).toHaveProperty('editor');&#10;      expect(usageData.breakdown[0]).toHaveProperty('acceptances_count');&#10;    });&#10;  });&#10;&#10;  describe('GET /github/copilot/seats', () =&gt; {&#10;    it('should return Copilot seat information for team members', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/seats')&#10;        .expect(200);&#10;&#10;      const seats = response.body as CopilotSeats;&#10;      expect(seats).toEqual(mockCopilotSeats);&#10;      expect(seats.total_seats).toBe(5);&#10;      expect(seats.seats).toHaveLength(3); // Your 3 teammates&#10;      expect(seats.seats[0].assignee.login).toBe('teammate1');&#10;    });&#10;&#10;    it('should provide seat data needed for filtering usage metrics', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/seats')&#10;        .expect(200);&#10;&#10;      const seatsData = response.body as CopilotSeats;&#10;      const { seats } = seatsData;&#10;&#10;      // Verify we can identify your specific teammates&#10;      const teammateLogins = seats.map((seat) =&gt; seat.assignee.login);&#10;      expect(teammateLogins).toContain('teammate1');&#10;      expect(teammateLogins).toContain('teammate2');&#10;      expect(teammateLogins).toContain('teammate3');&#10;&#10;      // Verify we have activity information&#10;      seats.forEach((seat) =&gt; {&#10;        expect(seat).toHaveProperty('last_activity_at');&#10;        expect(seat).toHaveProperty('last_activity_editor');&#10;      });&#10;    });&#10;  });&#10;&#10;  describe('GET /github/repos/:repo/pulls', () =&gt; {&#10;    it('should return pull requests for a specific repository', async () =&gt; {&#10;      const repo = 'test-repo';&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls`)&#10;        .expect(200);&#10;&#10;      const pullRequests = response.body as PullRequest[];&#10;      expect(pullRequests).toEqual(mockPullRequests);&#10;      expect(Array.isArray(pullRequests)).toBe(true);&#10;      expect(pullRequests[0]).toHaveProperty('number');&#10;      expect(pullRequests[0]).toHaveProperty('title');&#10;      expect(pullRequests[0]).toHaveProperty('user');&#10;    });&#10;&#10;    it('should accept since query parameter for date filtering', async () =&gt; {&#10;      const repo = 'test-repo';&#10;      const since = '2025-01-01';&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls?since=${since}`)&#10;        .expect(200);&#10;&#10;      const pullRequests = response.body as PullRequest[];&#10;      expect(pullRequests).toEqual(mockPullRequests);&#10;    });&#10;  });&#10;&#10;  describe('GET /github/repos/:repo/pulls/:pullNumber/reviews', () =&gt; {&#10;    it('should return reviews for a specific pull request', async () =&gt; {&#10;      const repo = 'test-repo';&#10;      const pullNumber = 123;&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls/${pullNumber}/reviews`)&#10;        .expect(200);&#10;&#10;      const reviews = response.body as PullRequestReview[];&#10;      expect(reviews).toEqual(mockPullRequestReviews);&#10;      expect(Array.isArray(reviews)).toBe(true);&#10;    });&#10;&#10;    it('should include both human and bot reviews for Copilot detection', async () =&gt; {&#10;      const repo = 'test-repo';&#10;      const pullNumber = 123;&#10;&#10;      const response = await request(app.getHttpServer())&#10;        .get(`/github/repos/${repo}/pulls/${pullNumber}/reviews`)&#10;        .expect(200);&#10;&#10;      const reviews = response.body as PullRequestReview[];&#10;&#10;      // Should have both bot and human reviews&#10;      const botReview = reviews.find((review) =&gt; review.user.type === 'Bot');&#10;      const humanReview = reviews.find((review) =&gt; review.user.type === 'User');&#10;&#10;      expect(botReview).toBeDefined();&#10;      expect(humanReview).toBeDefined();&#10;      expect(botReview?.user.login).toBe('github-actions[bot]');&#10;    });&#10;  });&#10;&#10;  describe('GET /github/copilot/summary', () =&gt; {&#10;    it('should return a combined summary of Copilot metrics for last 28 days', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/summary')&#10;        .expect(200);&#10;&#10;      const summary = response.body as CopilotSummary;&#10;      expect(summary).toHaveProperty('period');&#10;      expect(summary).toHaveProperty('usage_metrics');&#10;      expect(summary).toHaveProperty('seat_info');&#10;      expect(summary).toHaveProperty('summary');&#10;&#10;      // Verify period calculation&#10;      expect(summary.period.days).toBe(28);&#10;      expect(summary.period.since).toBeDefined();&#10;      expect(summary.period.until).toBeDefined();&#10;&#10;      // Verify summary statistics&#10;      expect(summary.summary.total_seats).toBe(5);&#10;      expect(summary.summary.total_active_users).toBe(1); // Length of mock usage metrics array&#10;    });&#10;&#10;    it('should provide data structure suitable for dashboard display', async () =&gt; {&#10;      const response = await request(app.getHttpServer())&#10;        .get('/github/copilot/summary')&#10;        .expect(200);&#10;&#10;      const summary = response.body as CopilotSummary;&#10;&#10;      // Frontend should be able to easily extract key metrics&#10;      expect(typeof summary.summary.total_seats).toBe('number');&#10;      expect(typeof summary.summary.total_active_users).toBe('number');&#10;      expect(Array.isArray(summary.usage_metrics)).toBe(true);&#10;      expect(Array.isArray(summary.seat_info.seats)).toBe(true);&#10;    });&#10;  });&#10;});&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/backend/test/setup.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/backend/test/setup.ts" />
              <option name="originalContent" value="import { afterAll, afterEach, beforeAll } from 'vitest';&#10;import { setupServer } from 'msw/node';&#10;import { http, HttpResponse } from 'msw';&#10;&#10;// Mock GitHub API responses - based on actual GitHub Copilot Metrics API structure&#10;export const mockCopilotUsageMetrics = [&#10;  {&#10;    day: '2025-01-01',&#10;    total_suggestions_count: 1500,&#10;    total_acceptances_count: 750,&#10;    total_lines_suggested: 12000,&#10;    total_lines_accepted: 6000,&#10;    total_active_users: 3,&#10;    total_chat_acceptances: 25,&#10;    total_chat_turns: 100,&#10;    total_active_chat_users: 2,&#10;    breakdown: [&#10;      {&#10;        language: 'typescript',&#10;        editor: 'vscode',&#10;        suggestions_count: 800,&#10;        acceptances_count: 400,&#10;        lines_suggested: 6400,&#10;        lines_accepted: 3200,&#10;        active_users: 2,&#10;      },&#10;      {&#10;        language: 'javascript',&#10;        editor: 'vscode',&#10;        suggestions_count: 700,&#10;        acceptances_count: 350,&#10;        lines_suggested: 5600,&#10;        lines_accepted: 2800,&#10;        active_users: 1,&#10;      },&#10;    ],&#10;  },&#10;];&#10;&#10;export const mockCopilotSeats = {&#10;  total_seats: 5,&#10;  seats: [&#10;    {&#10;      created_at: '2024-12-01T00:00:00Z',&#10;      updated_at: '2025-01-01T00:00:00Z',&#10;      pending_cancellation_date: null,&#10;      last_activity_at: '2025-01-15T10:30:00Z',&#10;      last_activity_editor: 'vscode',&#10;      assignee: {&#10;        login: 'teammate1',&#10;        id: 12345,&#10;        type: 'User',&#10;      },&#10;    },&#10;    {&#10;      created_at: '2024-12-01T00:00:00Z',&#10;      updated_at: '2025-01-01T00:00:00Z',&#10;      pending_cancellation_date: null,&#10;      last_activity_at: '2025-01-15T11:00:00Z',&#10;      last_activity_editor: 'vscode',&#10;      assignee: {&#10;        login: 'teammate2',&#10;        id: 12346,&#10;        type: 'User',&#10;      },&#10;    },&#10;    {&#10;      created_at: '2024-12-01T00:00:00Z',&#10;      updated_at: '2025-01-01T00:00:00Z',&#10;      pending_cancellation_date: null,&#10;      last_activity_at: '2025-01-15T09:45:00Z',&#10;      last_activity_editor: 'vscode',&#10;      assignee: {&#10;        login: 'teammate3',&#10;        id: 12347,&#10;        type: 'User',&#10;      },&#10;    },&#10;  ],&#10;};&#10;&#10;export const mockCurrentUser = {&#10;  login: 'advait-incubyte',&#10;  id: 215627961,&#10;  type: 'User',&#10;  name: 'Advait Maindalkar',&#10;  company: '@incubyte',&#10;};&#10;&#10;export const mockPullRequests = [&#10;  {&#10;    id: 1,&#10;    number: 123,&#10;    title: 'Add Copilot metrics collection',&#10;    user: { login: 'teammate1' },&#10;    created_at: '2025-01-10T10:00:00Z',&#10;    updated_at: '2025-01-10T12:00:00Z',&#10;    state: 'closed',&#10;    merged_at: '2025-01-10T12:00:00Z',&#10;  },&#10;  {&#10;    id: 2,&#10;    number: 124,&#10;    title: 'Fix authentication bug',&#10;    user: { login: 'teammate2' },&#10;    created_at: '2025-01-11T14:00:00Z',&#10;    updated_at: '2025-01-11T16:00:00Z',&#10;    state: 'open',&#10;    merged_at: null,&#10;  },&#10;];&#10;&#10;export const mockPullRequestReviews = [&#10;  {&#10;    id: 1,&#10;    user: { login: 'github-actions[bot]', type: 'Bot' },&#10;    body: 'Copilot review: This code looks good!',&#10;    state: 'APPROVED',&#10;    submitted_at: '2025-01-10T11:00:00Z',&#10;  },&#10;  {&#10;    id: 2,&#10;    user: { login: 'teammate3', type: 'User' },&#10;    body: 'LGTM!',&#10;    state: 'APPROVED',&#10;    submitted_at: '2025-01-10T11:30:00Z',&#10;  },&#10;];&#10;&#10;// MSW request handlers&#10;export const handlers = [&#10;  // Mock GitHub Copilot usage metrics endpoint&#10;  http.get('https://api.github.com/orgs/:org/copilot/usage', () =&gt; {&#10;    return HttpResponse.json(mockCopilotUsageMetrics);&#10;  }),&#10;&#10;  // Mock GitHub Copilot seats endpoint&#10;  http.get('https://api.github.com/orgs/:org/copilot/billing/seats', () =&gt; {&#10;    return HttpResponse.json(mockCopilotSeats);&#10;  }),&#10;&#10;  // Mock GitHub authenticated user endpoint&#10;  http.get('https://api.github.com/user', () =&gt; {&#10;    return HttpResponse.json(mockCurrentUser);&#10;  }),&#10;&#10;  // Mock GitHub pull requests endpoint&#10;  http.get('https://api.github.com/repos/:owner/:repo/pulls', () =&gt; {&#10;    return HttpResponse.json(mockPullRequests);&#10;  }),&#10;&#10;  // Mock GitHub pull request reviews endpoint&#10;  http.get(&#10;    'https://api.github.com/repos/:owner/:repo/pulls/:pull_number/reviews',&#10;    () =&gt; {&#10;      return HttpResponse.json(mockPullRequestReviews);&#10;    },&#10;  ),&#10;&#10;  // Mock error scenarios&#10;  http.get('https://api.github.com/orgs/invalid-org/copilot/usage', () =&gt; {&#10;    return HttpResponse.json({ message: 'Not Found' }, { status: 404 });&#10;  }),&#10;];&#10;&#10;// Create MSW server&#10;export const server = setupServer(...handlers);&#10;&#10;// Setup MSW&#10;beforeAll(() =&gt; {&#10;  server.listen({ onUnhandledRequest: 'error' });&#10;});&#10;&#10;afterEach(() =&gt; {&#10;  server.resetHandlers();&#10;});&#10;&#10;afterAll(() =&gt; {&#10;  server.close();&#10;});&#10;" />
              <option name="updatedContent" value="import { setupServer } from 'msw/node';&#10;import { http, HttpResponse } from 'msw';&#10;import { beforeAll, afterEach, afterAll } from 'vitest';&#10;&#10;// Type definitions for GitHub API responses&#10;export interface GitHubUser {&#10;  login: string;&#10;  id: number;&#10;  company: string | null;&#10;  email: string | null;&#10;  name: string | null;&#10;}&#10;&#10;export interface CopilotUsageBreakdown {&#10;  language: string;&#10;  editor: string;&#10;  suggestions_count: number;&#10;  acceptances_count: number;&#10;  lines_suggested: number;&#10;  lines_accepted: number;&#10;  active_users: number;&#10;}&#10;&#10;export interface CopilotUsageMetrics {&#10;  day: string;&#10;  total_suggestions_count: number;&#10;  total_acceptances_count: number;&#10;  total_lines_suggested: number;&#10;  total_lines_accepted: number;&#10;  total_active_users: number;&#10;  breakdown: CopilotUsageBreakdown[];&#10;}&#10;&#10;export interface CopilotSeatAssignee {&#10;  login: string;&#10;  id: number;&#10;  type: string;&#10;}&#10;&#10;export interface CopilotSeat {&#10;  assignee: CopilotSeatAssignee;&#10;  assigning_team: null;&#10;  pending_cancellation_date: string | null;&#10;  last_activity_at: string;&#10;  last_activity_editor: string;&#10;  created_at: string;&#10;  updated_at: string;&#10;}&#10;&#10;export interface CopilotSeats {&#10;  total_seats: number;&#10;  seats: CopilotSeat[];&#10;}&#10;&#10;export interface PullRequestUser {&#10;  login: string;&#10;  id: number;&#10;  type: string;&#10;}&#10;&#10;export interface PullRequest {&#10;  number: number;&#10;  title: string;&#10;  user: PullRequestUser;&#10;  created_at: string;&#10;  updated_at: string;&#10;  state: string;&#10;}&#10;&#10;export interface PullRequestReviewUser {&#10;  login: string;&#10;  id: number;&#10;  type: 'User' | 'Bot';&#10;}&#10;&#10;export interface PullRequestReview {&#10;  id: number;&#10;  user: PullRequestReviewUser;&#10;  state: string;&#10;  submitted_at: string;&#10;  body: string;&#10;}&#10;&#10;export interface CopilotSummary {&#10;  period: {&#10;    days: number;&#10;    since: string;&#10;    until: string;&#10;  };&#10;  usage_metrics: CopilotUsageMetrics[];&#10;  seat_info: CopilotSeats;&#10;  summary: {&#10;    total_seats: number;&#10;    total_active_users: number;&#10;    total_suggestions: number;&#10;    total_acceptances: number;&#10;    acceptance_rate: number;&#10;  };&#10;}&#10;&#10;// Mock data&#10;export const mockCurrentUser: GitHubUser = {&#10;  login: 'advait-incubyte',&#10;  id: 12345,&#10;  company: '@incubyte',&#10;  email: 'advait@incubyte.co',&#10;  name: 'Advait Maindalkar',&#10;};&#10;&#10;export const mockCopilotUsageMetrics: CopilotUsageMetrics[] = [&#10;  {&#10;    day: '2025-07-27',&#10;    total_suggestions_count: 150,&#10;    total_acceptances_count: 75,&#10;    total_lines_suggested: 300,&#10;    total_lines_accepted: 150,&#10;    total_active_users: 3,&#10;    breakdown: [&#10;      {&#10;        language: 'typescript',&#10;        editor: 'vscode',&#10;        suggestions_count: 100,&#10;        acceptances_count: 50,&#10;        lines_suggested: 200,&#10;        lines_accepted: 100,&#10;        active_users: 2,&#10;      },&#10;      {&#10;        language: 'javascript',&#10;        editor: 'vscode',&#10;        suggestions_count: 50,&#10;        acceptances_count: 25,&#10;        lines_suggested: 100,&#10;        lines_accepted: 50,&#10;        active_users: 1,&#10;      },&#10;    ],&#10;  },&#10;];&#10;&#10;export const mockCopilotSeats: CopilotSeats = {&#10;  total_seats: 5,&#10;  seats: [&#10;    {&#10;      assignee: {&#10;        login: 'teammate1',&#10;        id: 11111,&#10;        type: 'User',&#10;      },&#10;      assigning_team: null,&#10;      pending_cancellation_date: null,&#10;      last_activity_at: '2025-07-27T10:00:00Z',&#10;      last_activity_editor: 'vscode',&#10;      created_at: '2025-01-01T00:00:00Z',&#10;      updated_at: '2025-07-27T10:00:00Z',&#10;    },&#10;    {&#10;      assignee: {&#10;        login: 'teammate2',&#10;        id: 22222,&#10;        type: 'User',&#10;      },&#10;      assigning_team: null,&#10;      pending_cancellation_date: null,&#10;      last_activity_at: '2025-07-26T15:30:00Z',&#10;      last_activity_editor: 'vscode',&#10;      created_at: '2025-01-01T00:00:00Z',&#10;      updated_at: '2025-07-26T15:30:00Z',&#10;    },&#10;    {&#10;      assignee: {&#10;        login: 'teammate3',&#10;        id: 33333,&#10;        type: 'User',&#10;      },&#10;      assigning_team: null,&#10;      pending_cancellation_date: null,&#10;      last_activity_at: '2025-07-25T09:15:00Z',&#10;      last_activity_editor: 'vscode',&#10;      created_at: '2025-01-01T00:00:00Z',&#10;      updated_at: '2025-07-25T09:15:00Z',&#10;    },&#10;  ],&#10;};&#10;&#10;export const mockPullRequests: PullRequest[] = [&#10;  {&#10;    number: 123,&#10;    title: 'feat: add new feature',&#10;    user: {&#10;      login: 'teammate1',&#10;      id: 11111,&#10;      type: 'User',&#10;    },&#10;    created_at: '2025-07-20T10:00:00Z',&#10;    updated_at: '2025-07-21T10:00:00Z',&#10;    state: 'open',&#10;  },&#10;  {&#10;    number: 124,&#10;    title: 'fix: resolve bug in auth',&#10;    user: {&#10;      login: 'teammate2',&#10;      id: 22222,&#10;      type: 'User',&#10;    },&#10;    created_at: '2025-07-19T14:30:00Z',&#10;    updated_at: '2025-07-20T14:30:00Z',&#10;    state: 'closed',&#10;  },&#10;];&#10;&#10;export const mockPullRequestReviews: PullRequestReview[] = [&#10;  {&#10;    id: 1001,&#10;    user: {&#10;      login: 'github-actions[bot]',&#10;      id: 41898282,&#10;      type: 'Bot',&#10;    },&#10;    state: 'commented',&#10;    submitted_at: '2025-07-21T10:30:00Z',&#10;    body: 'GitHub Copilot review: This code looks good!',&#10;  },&#10;  {&#10;    id: 1002,&#10;    user: {&#10;      login: 'teammate3',&#10;      id: 33333,&#10;      type: 'User',&#10;    },&#10;    state: 'approved',&#10;    submitted_at: '2025-07-21T11:00:00Z',&#10;    body: 'LGTM! Great work on this feature.',&#10;  },&#10;];&#10;&#10;// MSW server setup&#10;const handlers = [&#10;  // GitHub User API&#10;  http.get('https://api.github.com/user', () =&gt; {&#10;    return HttpResponse.json(mockCurrentUser);&#10;  }),&#10;&#10;  // Copilot Usage Metrics API&#10;  http.get('https://api.github.com/orgs/:org/copilot/usage', () =&gt; {&#10;    return HttpResponse.json(mockCopilotUsageMetrics);&#10;  }),&#10;&#10;  // Copilot Seats API&#10;  http.get('https://api.github.com/orgs/:org/copilot/billing/seats', () =&gt; {&#10;    return HttpResponse.json(mockCopilotSeats);&#10;  }),&#10;&#10;  // Pull Requests API&#10;  http.get('https://api.github.com/repos/:org/:repo/pulls', () =&gt; {&#10;    return HttpResponse.json(mockPullRequests);&#10;  }),&#10;&#10;  // Pull Request Reviews API&#10;  http.get('https://api.github.com/repos/:org/:repo/pulls/:pullNumber/reviews', () =&gt; {&#10;    return HttpResponse.json(mockPullRequestReviews);&#10;  }),&#10;];&#10;&#10;export const server = setupServer(...handlers);&#10;&#10;// Setup MSW&#10;beforeAll(() =&gt; {&#10;  server.listen({ onUnhandledRequest: 'error' });&#10;});&#10;&#10;afterEach(() =&gt; {&#10;  server.resetHandlers();&#10;});&#10;&#10;afterAll(() =&gt; {&#10;  server.close();&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/App.tsx" />
              <option name="originalContent" value="import { useState } from 'react'&#10;import Header from './components/Header'&#10;import Dashboard from './components/Dashboard'&#10;import { DaysRangeProvider } from './context/DaysRangeContext'&#10;&#10;function App() {&#10;  const [daysRange, setDaysRange] = useState(30)&#10;&#10;  return (&#10;    &lt;DaysRangeProvider&gt;&#10;      &lt;div className=&quot;app-container&quot;&gt;&#10;        &lt;Header /&gt;&#10;        &lt;main&gt;&#10;          &lt;Dashboard /&gt;&#10;        &lt;/main&gt;&#10;        &lt;footer className=&quot;footer&quot;&gt;&#10;          &lt;p&gt;© {new Date().getFullYear()} Copilot Stats Dashboard&lt;/p&gt;&#10;        &lt;/footer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/DaysRangeProvider&gt;&#10;  )&#10;}&#10;&#10;export default App&#10;" />
              <option name="updatedContent" value="import Header from './components/Header'&#10;import Dashboard from './components/Dashboard'&#10;import { DaysRangeProvider } from './context/DaysRangeContext'&#10;&#10;function App() {&#10;  return (&#10;    &lt;DaysRangeProvider&gt;&#10;      &lt;div className=&quot;app-container&quot;&gt;&#10;        &lt;Header /&gt;&#10;        &lt;main&gt;&#10;          &lt;Dashboard /&gt;&#10;        &lt;/main&gt;&#10;        &lt;footer className=&quot;footer&quot;&gt;&#10;          &lt;p&gt;© {new Date().getFullYear()} Copilot Stats Dashboard&lt;/p&gt;&#10;        &lt;/footer&gt;&#10;      &lt;/div&gt;&#10;    &lt;/DaysRangeProvider&gt;&#10;  )&#10;}&#10;&#10;export default App" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/components/AIUsageSummary.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/components/AIUsageSummary.tsx" />
              <option name="updatedContent" value="import React from 'react'&#10;import { AIUsageStats } from '../services/github.service'&#10;&#10;interface AIUsageSummaryProps {&#10;  stats: AIUsageStats&#10;}&#10;&#10;const statLabels: Record&lt;keyof AIUsageStats, string&gt; = {&#10;  code: 'Code Generation',&#10;  review: 'PRs Reviewed by Copilot',&#10;  docs: 'Documentation',&#10;  other: 'Other',&#10;  test: 'Test Generation',&#10;}&#10;&#10;export const AIUsageSummary: React.FC&lt;AIUsageSummaryProps&gt; = ({ stats }) =&gt; {&#10;  return (&#10;    &lt;section className=&quot;ai-usage-summary&quot;&gt;&#10;      &lt;h2&gt;AI Usage Summary&lt;/h2&gt;&#10;      &lt;div className=&quot;ai-usage-cards&quot;&gt;&#10;        {Object.entries(stats).map(([key, value]) =&gt; (&#10;          &lt;div className=&quot;ai-usage-card&quot; key={key}&gt;&#10;            &lt;div className=&quot;ai-usage-value&quot;&gt;{value}&lt;/div&gt;&#10;            &lt;div className=&quot;ai-usage-label&quot;&gt;{statLabels[key as keyof AIUsageStats]}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;  )&#10;}&#10;&#10;export default AIUsageSummary&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/components/CopilotPRTable.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/components/CopilotPRTable.tsx" />
              <option name="updatedContent" value="import React from 'react'&#10;import { PullRequestData } from '../services/github.service'&#10;&#10;interface CopilotPRTableProps {&#10;  prsByRepo: Record&lt;string, PullRequestData[]&gt;&#10;}&#10;&#10;export const CopilotPRTable: React.FC&lt;CopilotPRTableProps&gt; = ({ prsByRepo }) =&gt; {&#10;  const repoNames = Object.keys(prsByRepo)&#10;  if (repoNames.length === 0) return &lt;div&gt;No PRs reviewed by Copilot found.&lt;/div&gt;&#10;&#10;  return (&#10;    &lt;section className=&quot;copilot-pr-table&quot;&gt;&#10;      &lt;h2&gt;Pull Requests Reviewed by Copilot&lt;/h2&gt;&#10;      {repoNames.map(repo =&gt; (&#10;        &lt;div key={repo} className=&quot;repo-section&quot;&gt;&#10;          &lt;h3&gt;{repo}&lt;/h3&gt;&#10;          &lt;table&gt;&#10;            &lt;thead&gt;&#10;              &lt;tr&gt;&#10;                &lt;th&gt;#&lt;/th&gt;&#10;                &lt;th&gt;Title&lt;/th&gt;&#10;                &lt;th&gt;Author&lt;/th&gt;&#10;                &lt;th&gt;Closed At&lt;/th&gt;&#10;                &lt;th&gt;AI Usage&lt;/th&gt;&#10;                &lt;th&gt;Copilot Review&lt;/th&gt;&#10;              &lt;/tr&gt;&#10;            &lt;/thead&gt;&#10;            &lt;tbody&gt;&#10;              {prsByRepo[repo].map(pr =&gt; (&#10;                &lt;tr key={pr.number}&gt;&#10;                  &lt;td&gt;{pr.number}&lt;/td&gt;&#10;                  &lt;td&gt;{pr.title}&lt;/td&gt;&#10;                  &lt;td&gt;{pr.author}&lt;/td&gt;&#10;                  &lt;td&gt;{new Date(pr.closed_at).toLocaleString()}&lt;/td&gt;&#10;                  &lt;td&gt;&#10;                    {Object.entries(pr.ai_usage)&#10;                      .filter(([_, v]) =&gt; v)&#10;                      .map(([k]) =&gt; k.charAt(0).toUpperCase() + k.slice(1))&#10;                      .join(', ') || 'None'}&#10;                  &lt;/td&gt;&#10;                  &lt;td&gt;&#10;                    &lt;a href={pr.copilot_review.url} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&#10;                      {pr.copilot_review.login}&#10;                    &lt;/a&gt;&#10;                  &lt;/td&gt;&#10;                &lt;/tr&gt;&#10;              ))}&#10;            &lt;/tbody&gt;&#10;          &lt;/table&gt;&#10;        &lt;/div&gt;&#10;      ))}&#10;    &lt;/section&gt;&#10;  )&#10;}&#10;&#10;export default CopilotPRTable&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/components/ErrorMessage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/components/ErrorMessage.tsx" />
              <option name="updatedContent" value="import React from 'react'&#10;&#10;interface ErrorMessageProps {&#10;  message: string&#10;}&#10;&#10;const ErrorMessage: React.FC&lt;ErrorMessageProps&gt; = ({ message }) =&gt; (&#10;  &lt;div className=&quot;error-message&quot; style={{ color: 'red', margin: '2em 0', textAlign: 'center' }}&gt;&#10;    &lt;strong&gt;Error:&lt;/strong&gt; {message}&#10;  &lt;/div&gt;&#10;)&#10;&#10;export default ErrorMessage&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/components/LoadingMessage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/components/LoadingMessage.tsx" />
              <option name="updatedContent" value="import React from 'react'&#10;&#10;const LoadingMessage: React.FC = () =&gt; (&#10;  &lt;div className=&quot;loading-message&quot; style={{ color: '#555', margin: '2em 0', textAlign: 'center' }}&gt;&#10;    &lt;span&gt;Loading Copilot statistics...&lt;/span&gt;&#10;  &lt;/div&gt;&#10;)&#10;&#10;export default LoadingMessage&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/services/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/services/api.ts" />
              <option name="originalContent" value="/**&#10; * API service to handle communication with the backend&#10; */&#10;&#10;import { useQuery } from '@tanstack/react-query';&#10;&#10;// Backend API base URL&#10;const API_BASE_URL = import.meta.env.VITE_BACKEND_URL;&#10;&#10;// Types based on the backend response&#10;export interface AIUsageStats {&#10;  code: number;&#10;  test: number;&#10;  review: number;&#10;  docs: number;&#10;  other: number;&#10;}&#10;&#10;export interface CopilotReview {&#10;  login: string;&#10;  type: string;&#10;  body: string;&#10;  url: string;&#10;}&#10;&#10;export interface PullRequest {&#10;  number: number;&#10;  title: string;&#10;  author: string;&#10;  closed_at: string;&#10;  repo: string;&#10;  ai_usage: AIUsageStats;&#10;  copilot_review: CopilotReview;&#10;}&#10;&#10;export interface CopilotUsageResponse {&#10;  pullRequestsReviewedByCopilot: Record&lt;string, PullRequest[]&gt;;&#10;  usageOfAI: AIUsageStats;&#10;}&#10;&#10;/**&#10; * Custom hook to subscribe to Copilot usage statistics SSE endpoint&#10; * @param daysRange - Number of days to look back for stats&#10; * @returns Query result with the statistics data&#10; */&#10;export function useCopilotStats(daysRange: number) {&#10;  return useQuery&lt;CopilotUsageResponse&gt;({&#10;    queryKey: ['copilot-stats', daysRange],&#10;    queryFn: () =&gt; {&#10;      return new Promise&lt;CopilotUsageResponse&gt;((resolve, reject) =&gt; {&#10;        // Create a new EventSource connection to the backend SSE endpoint - now using absolute URL&#10;        const eventSource = new EventSource(`${API_BASE_URL}/github/copilot/usage?daysRange=${daysRange}`);&#10;&#10;        // Handle incoming SSE messages&#10;        eventSource.onmessage = (event) =&gt; {&#10;          try {&#10;            // Skip if it's the close message&#10;            if (event.data === 'close') {&#10;              eventSource.close();&#10;              return;&#10;            }&#10;&#10;            // Parse the JSON data from the event&#10;            const data = JSON.parse(event.data) as CopilotUsageResponse;&#10;            resolve(data);&#10;&#10;            // Close the connection after receiving the data&#10;            eventSource.close();&#10;          } catch (error) {&#10;            console.error('Error parsing SSE data:', error);&#10;            eventSource.close();&#10;            reject(error);&#10;          }&#10;        };&#10;&#10;        // Handle errors in the SSE connection&#10;        eventSource.onerror = (error) =&gt; {&#10;          console.error('SSE connection error:', error);&#10;          eventSource.close();&#10;          reject(new Error('Failed to connect to SSE endpoint'));&#10;        };&#10;&#10;        // Cleanup function to close the connection if the component unmounts&#10;        return () =&gt; {&#10;          eventSource.close();&#10;        };&#10;      });&#10;    },&#10;    staleTime: 5 * 60 * 1000, // 5 minutes&#10;    refetchOnWindowFocus: false,&#10;  });&#10;}&#10;&#10;/**&#10; * Formats and processes raw statistics for UI presentation&#10; * @param stats - Raw AI usage statistics&#10; * @returns Formatted stats for UI presentation&#10; */&#10;export function formatAIUsageStats(stats: AIUsageStats) {&#10;  const total = Object.values(stats).reduce((sum, value) =&gt; sum + value, 0);&#10;&#10;  return {&#10;    chartData: {&#10;      labels: ['Code Generation', 'Test Generation', 'Reviews', 'Documentation', 'Other'],&#10;      datasets: [&#10;        {&#10;          label: 'AI Usage Distribution',&#10;          data: [stats.code, stats.test, stats.review, stats.docs, stats.other],&#10;          backgroundColor: [&#10;            'rgba(54, 162, 235, 0.6)',  // Blue for code&#10;            'rgba(75, 192, 192, 0.6)',  // Teal for test&#10;            'rgba(255, 99, 132, 0.6)',  // Red for review&#10;            'rgba(255, 206, 86, 0.6)',  // Yellow for docs&#10;            'rgba(153, 102, 255, 0.6)', // Purple for other&#10;          ],&#10;          borderColor: [&#10;            'rgba(54, 162, 235, 1)',&#10;            'rgba(75, 192, 192, 1)',&#10;            'rgba(255, 99, 132, 1)',&#10;            'rgba(255, 206, 86, 1)',&#10;            'rgba(153, 102, 255, 1)',&#10;          ],&#10;          borderWidth: 1,&#10;        },&#10;      ],&#10;    },&#10;    summaryData: {&#10;      total,&#10;      code: { value: stats.code, percentage: total ? Math.round((stats.code / total) * 100) : 0 },&#10;      test: { value: stats.test, percentage: total ? Math.round((stats.test / total) * 100) : 0 },&#10;      review: { value: stats.review, percentage: total ? Math.round((stats.review / total) * 100) : 0 },&#10;      docs: { value: stats.docs, percentage: total ? Math.round((stats.docs / total) * 100) : 0 },&#10;      other: { value: stats.other, percentage: total ? Math.round((stats.other / total) * 100) : 0 },&#10;    },&#10;  };&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * API service to handle communication with the backend&#10; */&#10;&#10;import { useQuery } from '@tanstack/react-query';&#10;&#10;// Backend API base URL&#10;const API_BASE_URL = import.meta.env.VITE_BACKEND_URL;&#10;&#10;// Types based on the backend response&#10;export interface AIUsageStats {&#10;  code: number;&#10;  test: number;&#10;  review: number;&#10;  docs: number;&#10;  other: number;&#10;}&#10;&#10;export interface CopilotReview {&#10;  login: string;&#10;  type: string;&#10;  body: string;&#10;  url: string;&#10;}&#10;&#10;export interface PullRequest {&#10;  number: number;&#10;  title: string;&#10;  author: string;&#10;  closed_at: string;&#10;  repo: string;&#10;  ai_usage: AIUsageStats;&#10;  copilot_review: CopilotReview;&#10;}&#10;&#10;export interface CopilotUsageResponse {&#10;  pullRequestsReviewedByCopilot: Record&lt;string, PullRequest[]&gt;;&#10;  usageOfAI: AIUsageStats;&#10;}&#10;&#10;/**&#10; * Custom hook to subscribe to Copilot usage statistics SSE endpoint&#10; * @param daysRange - Number of days to look back for stats&#10; * @returns Query result with the statistics data&#10; */&#10;export function useCopilotStats(daysRange: number) {&#10;  return useQuery&lt;CopilotUsageResponse&gt;({&#10;    queryKey: ['copilot-stats', daysRange],&#10;    queryFn: () =&gt; {&#10;      return new Promise&lt;CopilotUsageResponse&gt;((resolve, reject) =&gt; {&#10;        // Create a new EventSource connection to the backend SSE endpoint - now using absolute URL&#10;        const eventSource = new EventSource(`${API_BASE_URL}/github/copilot/usage?daysRange=${daysRange}`);&#10;&#10;        // Handle incoming SSE messages&#10;        eventSource.onmessage = (event) =&gt; {&#10;          try {&#10;            // Skip if it's the close message&#10;            if (event.data === 'close') {&#10;              eventSource.close();&#10;              return;&#10;            }&#10;&#10;            // Parse the JSON data from the event&#10;            const data = JSON.parse(event.data) as CopilotUsageResponse;&#10;            resolve(data);&#10;&#10;            // Close the connection after receiving the data&#10;            eventSource.close();&#10;          } catch (error) {&#10;            console.error('Error parsing SSE data:', error);&#10;            eventSource.close();&#10;            reject(error);&#10;          }&#10;        };&#10;&#10;        // Handle errors in the SSE connection&#10;        eventSource.onerror = (error) =&gt; {&#10;          console.error('SSE connection error:', error);&#10;          eventSource.close();&#10;          reject(new Error('Failed to connect to SSE endpoint'));&#10;        };&#10;&#10;        // Cleanup function to close the connection if the component unmounts&#10;        return () =&gt; {&#10;          eventSource.close();&#10;        };&#10;      });&#10;    },&#10;    staleTime: 5 * 60 * 1000, // 5 minutes&#10;    refetchOnWindowFocus: false,&#10;  });&#10;}&#10;&#10;/**&#10; * Formats and processes raw statistics for UI presentation&#10; * @param stats - Raw AI usage statistics&#10; * @returns Formatted stats for UI presentation&#10; */&#10;export function formatAIUsageStats(stats: AIUsageStats) {&#10;  const total = Object.values(stats).reduce((sum, value) =&gt; sum + value, 0);&#10;&#10;  return {&#10;    chartData: {&#10;      labels: ['Code Generation', 'Test Generation', 'Reviews', 'Documentation', 'Other'],&#10;      datasets: [&#10;        {&#10;          label: 'AI Usage Distribution',&#10;          data: [stats.code, stats.test, stats.review, stats.docs, stats.other],&#10;          backgroundColor: [&#10;            'rgba(54, 162, 235, 0.6)',  // Blue for code&#10;            'rgba(75, 192, 192, 0.6)',  // Teal for test&#10;            'rgba(255, 99, 132, 0.6)',  // Red for review&#10;            'rgba(255, 206, 86, 0.6)',  // Yellow for docs&#10;            'rgba(153, 102, 255, 0.6)', // Purple for other&#10;          ],&#10;          borderColor: [&#10;            'rgba(54, 162, 235, 1)',&#10;            'rgba(75, 192, 192, 1)',&#10;            'rgba(255, 99, 132, 1)',&#10;            'rgba(255, 206, 86, 1)',&#10;            'rgba(153, 102, 255, 1)',&#10;          ],&#10;          borderWidth: 1,&#10;        },&#10;      ],&#10;    },&#10;    summaryData: {&#10;      total,&#10;      code: { value: stats.code, percentage: total ? Math.round((stats.code / total) * 100) : 0 },&#10;      test: { value: stats.test, percentage: total ? Math.round((stats.test / total) * 100) : 0 },&#10;      review: { value: stats.review, percentage: total ? Math.round((stats.review / total) * 100) : 0 },&#10;      docs: { value: stats.docs, percentage: total ? Math.round((stats.docs / total) * 100) : 0 },&#10;      other: { value: stats.other, percentage: total ? Math.round((stats.other / total) * 100) : 0 },&#10;    },&#10;  };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/services/github.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/services/github.service.ts" />
              <option name="updatedContent" value="export interface AIUsageStats {&#10;  code: number&#10;  review: number&#10;  docs: number&#10;  other: number&#10;  test: number&#10;}&#10;&#10;export interface CopilotReview {&#10;  login: string&#10;  type: string&#10;  body: string&#10;  url: string&#10;}&#10;&#10;export interface PullRequestData {&#10;  number: number&#10;  title: string&#10;  author: string&#10;  closed_at: string&#10;  repo: string&#10;  ai_usage: AIUsageStats&#10;  copilot_review: CopilotReview&#10;}&#10;&#10;export interface CopilotUsageResponse {&#10;  pullRequestsReviewedByCopilot: Record&lt;string, PullRequestData[]&gt;&#10;  usageOfAI: AIUsageStats&#10;}&#10;&#10;export function getCopilotUsageStatsSSE(&#10;  daysRange: number,&#10;  onMessage: (data: CopilotUsageResponse) =&gt; void,&#10;  onError?: (err: any) =&gt; void&#10;): () =&gt; void {&#10;  const baseUrl = import.meta.env.VITE_BACKEND_BASE_URL || ''&#10;  const url = `${baseUrl}/github/copilot/usage?daysRange=${daysRange}`&#10;  const eventSource = new EventSource(url)&#10;&#10;  eventSource.onmessage = (event) =&gt; {&#10;    if (event.data === 'close') {&#10;      eventSource.close()&#10;      return&#10;    }&#10;    try {&#10;      const parsed = JSON.parse(event.data)&#10;      onMessage(parsed)&#10;    } catch (err) {&#10;      if (onError) onError(err)&#10;    }&#10;  }&#10;&#10;  eventSource.onerror = (err) =&gt; {&#10;    if (onError) onError(err)&#10;    eventSource.close()&#10;  }&#10;&#10;  return () =&gt; eventSource.close()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/src/vite-env.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/src/vite-env.d.ts" />
              <option name="updatedContent" value="/// &lt;reference types=&quot;vite/client&quot; /&gt;&#10;&#10;interface ImportMetaEnv {&#10;  readonly VITE_PORT: string&#10;  readonly VITE_API_URL: string&#10;  // Add other VITE_ prefixed environment variables here as needed&#10;}&#10;&#10;interface ImportMeta {&#10;  readonly env: ImportMetaEnv&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/tsconfig.json" />
              <option name="originalContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;useDefineForClassFields&quot;: true,&#10;    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;skipLibCheck&quot;: true,&#10;&#10;    /* Bundler mode */&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;allowImportingTsExtensions&quot;: true,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;isolatedModules&quot;: true,&#10;    &quot;noEmit&quot;: true,&#10;    &quot;jsx&quot;: &quot;react-jsx&quot;,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;&#10;    /* Linting */&#10;    &quot;strict&quot;: true,&#10;    &quot;noUnusedLocals&quot;: true,&#10;    &quot;noUnusedParameters&quot;: true,&#10;    &quot;noFallthroughCasesInSwitch&quot;: true,&#10;&#10;    /* Path aliases */&#10;    &quot;baseUrl&quot;: &quot;.&quot;,&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;./src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&quot;src&quot;],&#10;  &quot;references&quot;: [{ &quot;path&quot;: &quot;./tsconfig.node.json&quot; }]&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;useDefineForClassFields&quot;: true,&#10;    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;skipLibCheck&quot;: true,&#10;&#10;    /* Bundler mode */&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;allowImportingTsExtensions&quot;: true,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;isolatedModules&quot;: true,&#10;    &quot;noEmit&quot;: true,&#10;    &quot;jsx&quot;: &quot;react-jsx&quot;,&#10;    &quot;jsxImportSource&quot;: &quot;react&quot;,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;&#10;    /* Linting */&#10;    &quot;strict&quot;: true,&#10;    &quot;noUnusedLocals&quot;: true,&#10;    &quot;noUnusedParameters&quot;: true,&#10;    &quot;noFallthroughCasesInSwitch&quot;: true,&#10;&#10;    /* Path aliases */&#10;    &quot;baseUrl&quot;: &quot;.&quot;,&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;./src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&quot;src&quot;, &quot;src/**/*.ts&quot;, &quot;src/**/*.tsx&quot;],&#10;  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;],&#10;  &quot;references&quot;: [{ &quot;path&quot;: &quot;./tsconfig.node.json&quot; }]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/tsconfig.node.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/tsconfig.node.json" />
              <option name="originalContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;composite&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;strict&quot;: true,&#10;    &quot;jsx&quot;: &quot;react-jsx&quot;,&#10;    &quot;jsxImportSource&quot;: &quot;react&quot;,&#10;    &quot;types&quot;: [&quot;vite/client&quot;]&#10;  },&#10;  &quot;include&quot;: [&quot;vite.config.ts&quot;, &quot;src/vite-env.d.ts&quot;]&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;composite&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;strict&quot;: true,&#10;    &quot;jsx&quot;: &quot;react-jsx&quot;,&#10;    &quot;jsxImportSource&quot;: &quot;react&quot;,&#10;    &quot;types&quot;: [&quot;vite/client&quot;]&#10;  },&#10;  &quot;include&quot;: [&quot;vite.config.ts&quot;, &quot;src/vite-env.d.ts&quot;]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/vite.config.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/vite.config.ts" />
              <option name="originalContent" value="import { defineConfig } from 'vite';&#10;import react from '@vitejs/plugin-react';&#10;import path from 'path';&#10;&#10;// Use the same PORT variable as the backend for consistency&#10;const BACKEND_PORT = process.env.PORT || '3006';&#10;&#10;// https://vitejs.dev/config/&#10;export default defineConfig({&#10;  plugins: [&#10;    react({&#10;      // Enable automatic JSX runtime - no need to import React&#10;      jsxRuntime: 'automatic',&#10;    }),&#10;  ],&#10;  resolve: {&#10;    alias: {&#10;      '@': path.resolve(__dirname, './src'),&#10;    },&#10;  },&#10;  server: {&#10;    proxy: {&#10;      '/github': {&#10;        target: `http://localhost:${BACKEND_PORT}`,&#10;        changeOrigin: true,&#10;      },&#10;    },&#10;  },&#10;});&#10;" />
              <option name="updatedContent" value="import { defineConfig } from 'vite';&#10;import react from '@vitejs/plugin-react';&#10;import path from 'path';&#10;&#10;// https://vitejs.dev/config/&#10;export default defineConfig({&#10;  plugins: [&#10;    react({&#10;      // Enable automatic JSX runtime - no need to import React&#10;      jsxRuntime: 'automatic',&#10;    }),&#10;  ],&#10;  resolve: {&#10;    alias: {&#10;      '@': path.resolve(__dirname, './src'),&#10;    },&#10;  },&#10;  server: {&#10;    port: 8008,  // Frontend runs on port 8008&#10;    // Removed proxy since we're using CORS now&#10;  },&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>